# coroutine
称为用户态线程
线程是进程的执行体，在虚拟地址空间中，有内核栈，用户栈，代码段。  
cpu保存线程的栈基，栈指针，指令指针
而线程又可以分配多个执行体，成为协程，线程保存其标识符，执行栈位置，执行入口，执行现场
协程可以在用户态进行调度，对os内核透明。
协程的切换涉及到执行现场的保存和恢复。

# IO 
在进程控制信息中，记录着打开文件描述符。
进程每打开一个socket，就要增加一条记录，同时在内核空间分配读写缓冲区  

## 阻塞式IO
在等待socket就绪的过程中，放弃cpu，进去等待队列。
就绪后重新执行，处理一个socket，需要占用一个线程

## 非阻塞IO
不让出cpu，且不断地检查，这是一种忙等待，空耗cpu

## multiplexing
需要等待的socket加入监听集合，一次系统调用监听多个socket

### select
监听1024个，每次传入所有监听集合，每次遍历所有集合

### epoll
`epoll_createl`创建，`epoll_ctl`添加或删除，`epoll_wait`等待就绪
需要保存和恢复现场，来回切换。
适合用协程处理，每次遇到io事件，就注册一个协程，让出cpu。io等待结束后，就继续执行。
结构：协程->协程池->io multiplexing->frame->dev
