# compile and link for c++
1. source code .cpp
2. 预处理器：头文件的包含，宏扩展，条件编译，行控制 .i
3. 编译器：通过词法分析和语法分析，将经过预处理的程序变为汇编代码
4. 汇编：将汇编代码翻译成目标机器语言。成为object code(可重定位文件)
目标文件：
1. 代码段：程序的指令
2. 数据段：全局变量或静态的数据


## 链接
链接器：将多个目标文件外加库链接为一个可执行文件
1. 静态链接：将代码拷贝到可执行程序中，体积较大(编译时)
2. 动态链接：通过DLL动态调用(加载，运行时)


# coroutine
称为用户态线程
线程是进程的执行体，在虚拟地址空间中，有内核栈，用户栈，代码段。  
cpu保存线程的栈基，栈指针，指令指针
而线程又可以分配多个执行体，成为协程，线程保存其标识符，执行栈位置，执行入口，执行现场
协程可以在用户态进行调度，对os内核透明。
协程的切换涉及到执行现场的保存和恢复。

# IO 
在进程控制信息中，记录着打开文件描述符。
进程每打开一个socket，就要增加一条记录，同时在内核空间分配读写缓冲区  

## 阻塞式IO
在等待socket就绪的过程中，放弃cpu，进去等待队列。
就绪后重新执行，处理一个socket，需要占用一个线程

## 非阻塞IO
不让出cpu，且不断地检查，这是一种忙等待，空耗cpu

## multiplexing
需要等待的socket加入监听集合，一次系统调用监听多个socket

### select
监听1024个，每次传入所有监听集合，每次遍历所有集合

### epoll
`epoll_createl`创建，`epoll_ctl`添加或删除，`epoll_wait`等待就绪
需要保存和恢复现场，来回切换。
适合用协程处理，每次遇到io事件，就注册一个协程，让出cpu。io等待结束后，就继续执行。
结构：协程->协程池->io multiplexing->frame->dev


# function call
程序经过编译生成可执行文件，这些指令在虚拟内存空间中，位于代码段

## 栈帧
当函数执行所需要的存储空间超出寄存器能够存放的大小时，就会借助栈上的存储空间，成为栈帧
函数执行需要有内存空间存放局部变量，参数等数据，这段空间对应到虚拟地址空间的栈
栈在高地址向下增长，分配给函数的栈空间叫stack frame
栈底一般叫栈基bp,栈顶又叫栈指针sp
布局为：
1. caller's bp
2. local variables
3. return value
4. parameters

## 执行过程(golang)
### param and return
1. 分配return value
2. 参数压栈，从右到左

### call做两件事：
1. 将下一条指令的地址，即返回地址入栈
2. 跳转到指定函数入口地址

### 接着进入函数运行
1. 首先修改sp分配栈帧(golang)
2. 将caller's bp 保存入栈
3. 修改bp寄存器为本身的bp
4. 执行自身指令

### 在ret前，有两条指令
1. 恢复caller's bp
2. 修改sp，释放栈帧空间

### 执行ret指令
1. 弹出call指令压栈的返回地址
2. 跳转到返回地址，修改pc

## C++_version

1. 参数压栈
2. call指令将下一条指令的地址压栈，并调用函数
3. 函数开始执行，ebp压栈
4. ebp变为当前esp
5. 分配栈帧
6. 函数执行完毕，准备return value
7. esp变为ebp回收栈帧
8. pop ebp回到caller栈底
9. ret 将ESP指向的return address弹出，存储到EIP，调用结束
10. caller清理参数，接收返回值


# process and thread
每个进程有自己的虚拟地址空间，分为用户和内核空间
os运行在kernel，program运行在用户空间
内核空间有所有进程地址空间共享，program不能访问内核地址空间
内核保存进程控制信息
线程是进程执行体，有执行入口以及进程分配的内核栈和用户栈
进程：PCB 线程:TCB
LINUX:`task_struct`指定子进程和自己，共享地址空间和句柄表
线程是os调度与执行的基本单位
线程在自己的用户栈进行函数调用，但也要系统调用
os有中断向量表，linux： 0x80-系统调用派发(系统调用表)
cpu有中断控制器，执行到指定指令(syscall)，陷入内核
cpu分时间片，有时间片才能执行。并行
时间片用完后，时钟中断，线程调度
进程切换，还要切换页目录地址，进程地址空间资源变化，TLB缓冲失效
进程是程序的动态执行过程，进程间通信，IPC
虚拟内存，每个进程有一个从0开始的地址空间，以为自己独占着整个内存
一个执行流就是一个线程，对应一个pc，寄存器，堆栈，共享地址空间，全局变量，打开的文件
线程是并行的单位，同时执行一些指令，每个线程以为独占cpu，虚拟cpu

# thread and coroutine
线程和协程区别在于，一个由os内核调度，一个对os内核透明，由用户进行调度


# virtual memory
当一个可执行文件被加载到RAM中时，便成为了一个进程 

## 进程直接使用物理地址
很容易发生覆盖其他进程内存甚至os内存的情况

## 保护模式
os负责，通过内存分页机制，把虚拟内存映射到物理内存
每个进程存储当前页目录的物理地址
虚拟内存页通过页表映射到物理内存页
每个进程对应自己的页表，相同的虚拟地址映射不同的物理地址，实现进程地址空间的隔离
也可以实现进程间共享内存
虚拟地址通过MMU进行转换，页目录地址保存到特定寄存器
转换过的关系保存到TLB，切换进程要切换页目录，且TLB失效。

通过虚拟内存，可以不用将整个程序移动到内存中
而当真正映射到指定的内存时，发生pagefault

## 多级页表
可以只让部分页表保存在内存中

