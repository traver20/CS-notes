# Longest Increasing Subsequence
求数组的最长上升子序列长度，以下简称LIS
> A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].

## Dynamic programming
维护一个LIS的列表，不断更新，当遍历完数组后，列表中最长的即是答案  
那么如何存储LIS的列表？  
首先观察，对于一个LIS，一个元素，只有当其大于LIS末尾元素时，可以将其扩展  
所以我们只关心LIS的**长度和末尾元素**  
故只要在一个数组中，在长度对应的下标存储末尾元素，就可以做到存储LIS了  

这种情况，每一个长度只能存储一个LIS，但是在同样长度的LIS里，我们只需要保存末尾元素最小的那一个就可以，因为它是最容易被扩展的  

## Algorithms
算法步骤如下:
假设当前元素为x  
1. 二分查找LIS列表，找到末尾元素小于x的最长的LIS
2. 扩展该LIS，并且舍弃掉相同长度的其他LIS

因为我们使用数组存储LIS的列表，所以扩展的位置将是最后一个小于x的元素下标+1的位置  
因此二分查找时，只要找到第一个大于等于x的元素下标，将该元素替换为x即可  

维基百科的一个例子：{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}. 

    A[0] = 0. Case 1. There are no active lists, create one.
    0.
    -----------------------------------------------------------------------------
    A[1] = 8. Case 2. Clone and extend.
    0.
    0, 8.
    -----------------------------------------------------------------------------
    A[2] = 4. Case 3. Clone, extend and discard.
    0.
    0, 4.
    0, 8. Discarded
    -----------------------------------------------------------------------------
    A[3] = 12. Case 2. Clone and extend.
    0.
    0, 4.
    0, 4, 12.
    -----------------------------------------------------------------------------
    A[4] = 2. Case 3. Clone, extend and discard.
    0.
    0, 2.
    0, 4. Discarded.
    0, 4, 12.
    -----------------------------------------------------------------------------
    A[5] = 10. Case 3. Clone, extend and discard.
    0.
    0, 2.
    0, 2, 10.
    0, 4, 12. Discarded.
    -----------------------------------------------------------------------------
    A[6] = 6. Case 3. Clone, extend and discard.
    0.
    0, 2.
    0, 2, 6.
    0, 2, 10. Discarded.
    -----------------------------------------------------------------------------
    A[7] = 14. Case 2. Clone and extend.
    0.
    0, 2.
    0, 2, 6.
    0, 2, 6, 14.
    -----------------------------------------------------------------------------
    A[8] = 1. Case 3. Clone, extend and discard.
    0.
    0, 1.
    0, 2. Discarded.
    0, 2, 6.
    0, 2, 6, 14.
    -----------------------------------------------------------------------------
    A[9] = 9. Case 3. Clone, extend and discard.
    0.
    0, 1.
    0, 2, 6.
    0, 2, 6, 9.
    0, 2, 6, 14. Discarded.
    -----------------------------------------------------------------------------
    A[10] = 5. Case 3. Clone, extend and discard.
    0.
    0, 1.
    0, 1, 5.
    0, 2, 6. Discarded.
    0, 2, 6, 9.
    -----------------------------------------------------------------------------
    A[11] = 13. Case 2. Clone and extend.
    0.
    0, 1.
    0, 1, 5.
    0, 2, 6, 9.
    0, 2, 6, 9, 13.
    -----------------------------------------------------------------------------
    A[12] = 3. Case 3. Clone, extend and discard.
    0.
    0, 1.
    0, 1, 3.
    0, 1, 5. Discarded.
    0, 2, 6, 9.
    0, 2, 6, 9, 13.
    -----------------------------------------------------------------------------
    A[13] = 11. Case 3. Clone, extend and discard.
    0.
    0, 1.
    0, 1, 3.
    0, 2, 6, 9.
    0, 2, 6, 9, 11.
    0, 2, 6, 9, 13. Discarded.
    -----------------------------------------------------------------------------
    A[14] = 7. Case 3. Clone, extend and discard.
    0.
    0, 1.
    0, 1, 3.
    0, 1, 3, 7.
    0, 2, 6, 9. Discarded.
    0, 2, 6, 9, 11.
    ----------------------------------------------------------------------------
    A[15] = 15. Case 2. Clone and extend.
    0.
    0, 1.
    0, 1, 3.
    0, 1, 3, 7.
    0, 2, 6, 9, 11.
    0, 2, 6, 9, 11, 15. <-- LIS List
    ----------------------------------------------------------------------------

## code
~~~cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int len=0;
        for(auto x : nums)
        {
            int lo=0,hi=len;
            while(lo<hi)
            {
                int mid=(lo+hi)/2;
                if(nums[mid]<x)
                    lo=mid+1;//找到第一个>=x的下标
                else
                    hi=mid;
            }
            //简单的替换元素，既做到了扩展列表，同时也舍弃了相同长度的其他LIS
            nums[lo]=x;//可以新开一个数组存储LIS列表，这里节省空间，直接用了原数组
            if(lo==len)
                ++len;//更新最大长度
        }
        return len;
    }
};
~~~
